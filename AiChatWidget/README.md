# Виджет чата с ИИ

Интерфейс чата с интеграцией LLM и доступом к табличным данным для платформы APITable.

## Обзор

Данный проект реализует интерфейс разговорного ИИ-чата, разработанный для работы в качестве виджета в экосистеме APITable. Виджет подключается к OpenRouter API для получения ответов от языковых моделей и интегрируется с табличными данными платформы APITable, позволяя ИИ-ассистенту обращаться к структурированным данным и использовать их в процессе общения.

## Возможности

- Потоковая передача ответов от языковых моделей в реальном времени
- Интерфейс с пузырьками сообщений для пользователя и ассистента
- Поддержка форматирования Markdown в ответах ИИ
- Интеграция с источниками данных APITable
- Автоматическое внедрение контекста из табличных записей
- Автопрокрутка интерфейса чата
- Адаптивное текстовое поле ввода с автоматической регулировкой высоты

## Установка и настройка

### Шаг 1. Создание таблицы в MWS Tables

Начните с создания новой таблицы в MWS Tables. Заполните её данными, которые будут доступны вашему AI-ассистенту.

### Шаг 2. Создание виджета

После того как таблица готова, создайте пользовательский виджет в вашем пространстве MWS Tables.

### Шаг 3. Загрузка файлов проекта

1. Откройте папку `src` в директории вашего виджета
2. Удалите все файлы из этой папки
3. Скачайте файлы из [удалённого репозитория](https://github.com/root-0-0-0-0-chmod-x-dreams/Hack-n-Change-2025-MTC-Web-DA/tree/widget-chat/AiChatWidget)
4. Скопируйте скачанные файлы в папку `src`

### Шаг 4. Настройка API-токенов

Откройте [файл index.tsx](https://github.com/root-0-0-0-0-chmod-x-dreams/Hack-n-Change-2025-MTC-Web-DA/blob/widget-chat/AiChatWidget/index.tsx) и замените токены на свои:

**Получение токена для OpenRouter (LLM):**
- Перейдите на страницу [OpenRouter API Keys](https://openrouter.ai/settings/keys)
- Создайте новый ключ и скопируйте его

**Получение токена для таблицы:**
- Откройте вашу таблицу в MWS Tables
- Перейдите в раздел "Дополнительно"
- В графе "API" сгенерируйте и скопируйте токен

### Шаг 5. Запуск виджета

1. Откройте терминал в корневой директории вашего виджета
2. Выполните команду: ```widget-cli start```
3. Скопируйте ссылку из терминала
4. Вставьте эту ссылку на странице настроек виджета

Готово! Теперь вы можете пользоваться AI-чатом с доступом к данным вашей таблицы.


## Архитектура

### Основные компоненты

#### Компонент AiChatWidget
Главный React-компонент, управляющий интерфейсом чата. Управляет состоянием приложения, включая историю сообщений, состояния загрузки и табличные данные. Обрабатывает взаимодействие с пользователем и координирует связь между сервисами.

**Основные обязанности:**
- Управление состоянием сообщений
- Обработка пользовательского ввода
- Инициализация и координация сервисов
- Рендеринг интерфейса и компоновка

#### LLMService
Сервисный класс, отвечающий за связь с OpenRouter API. Обрабатывает HTTP-запросы, потоковые ответы и форматирование сообщений.

**Основные методы:**
- `sendMessage()` - отправляет сообщения в API LLM с поддержкой потоковой передачи
- `handleStreamResponse()` - обрабатывает события от потокового API
- `formatMessages()` - преобразует историю чата в формат, совместимый с API

**Конфигурация:**
- Базовый URL: `https://openrouter.ai/api/v1`
- Модель по умолчанию: `nvidia/nemotron-nano-12b-v2-vl:free`
- Поддерживает настраиваемые параметры: temperature, max_tokens, режим потоковой передачи

#### TableService
Сервисный класс для получения и форматирования данных из APITable API. Извлекает записи из указанных таблиц и представлений.

**Основные методы:**
- `fetchRecords()` - получает записи из APITable с параметрами запроса
- `formatRecordsForLLM()` - преобразует табличные записи в текстовый формат для контекста LLM

**Конфигурация:**
- Базовый URL: `https://tables.mws.ru/fusion/v1`
- ID таблицы: `dstjG1N3uvLFeF64X9`
- Представление по умолчанию: `viwaiHmHTClHK`

**Поддерживаемые параметры запроса:**
- `viewId` - конкретное представление для запроса
- `pageNum`, `pageSize` - управление пагинацией
- `fieldKey` - формат имени поля (name или id)
- `fields` - конкретные поля для возврата
- `sort` - конфигурация сортировки
- `filterByFormula` - фильтрация на основе формул
- `maxRecords` - максимальный лимит записей
- `cellFormat` - формат значения ячейки (json или string)

#### MarkdownRenderer
Пользовательский React-компонент для парсинга и рендеринга Markdown-синтаксиса в сообщениях ассистента. Поддерживает основные элементы Markdown без внешних зависимостей.

**Поддерживаемый синтаксис:**
- Заголовки (h1-h4)
- Жирный и курсивный текст
- Встроенный код и блоки кода
- Упорядоченные и неупорядоченные списки
- Ссылки
- Горизонтальные линии
- Цитаты

### Компоненты пользовательского интерфейса

#### Контейнер чата
Flex-контейнер во всю высоту, содержащий область сообщений и секцию ввода.

#### Контейнер сообщений
Прокручиваемая область, отображающая пузырьки сообщений. Реализует поведение автопрокрутки при поступлении новых сообщений. Кастомная стилизация скроллбара для webkit-браузеров.

#### Пузырьки сообщений
Различная стилизация для сообщений пользователя и ассистента:
- Сообщения пользователя: синий фон, белый текст, выравнивание справа
- Сообщения ассистента: белый фон, тёмный текст, выравнивание слева, включен рендеринг Markdown

#### Контейнер ввода
Фиксированная нижняя секция, содержащая текстовое поле и кнопку отправки. Текстовое поле автоматически регулирует высоту в зависимости от содержимого до максимума 120px.

#### Кнопка отправки
Круглая кнопка с иконкой стрелки. Отключается, когда поле ввода пустое или во время загрузки. Визуальная обратная связь при наведении и в отключенном состоянии.

#### Индикатор набора
Отображается во время ожидания ответа ассистента. Показывает сообщение "AI печатает..." в стиле сообщений ассистента.

## Поток данных

### Процесс отправки сообщения

1. Пользователь вводит текст в текстовое поле и отправляет через кнопку или клавишу Enter
2. Сообщение пользователя добавляется в состояние и немедленно отображается
3. Создается пустой заполнитель сообщения ассистента
4. Табличные данные загружаются и форматируются как системный контекст
5. История сообщений подготавливается и комбинируется с контекстом таблицы
6. Запрос отправляется в OpenRouter API с включенной потоковой передачей
7. Фрагменты ответа получаются и накапливаются в ref
8. Сообщение ассистента обновляется в реальном времени с накопленным контентом
9. Состояние загрузки очищается при завершении потока

### Интеграция табличных данных

1. Табличные данные загружаются при монтировании компонента
2. Записи сохраняются в состоянии компонента
3. При каждой отправке сообщения табличные данные форматируются как текст
4. Отформатированные данные внедряются как системное сообщение перед сообщениями пользователя
5. LLM имеет доступ к контексту таблицы для всех ответов

### Реализация потоковой передачи

Использует Server-Sent Events (SSE) через Fetch API. Тело ответа читается как поток с использованием ReadableStream reader. Текст декодируется инкрементально и парсится построчно. Каждый фрагмент, содержащий дельту контента, обновляет состояние сообщения.

## Стилизация

### Архитектура CSS

Единая таблица стилей (`chat.css`), содержащая все стили компонентов. Использует BEM-подобные соглашения об именовании для ясности. Включает базовые стили и специфичные для Markdown стили.

### Ключевые особенности стилей

- Компоновка на основе Flexbox для адаптивного поведения
- CSS-анимации для появления сообщений
- Кастомная стилизация скроллбара
- Состояния hover и focus для интерактивных элементов
- Адаптивная типографика с системным стеком шрифтов
- Стилизация Markdown-контента изолирована в области `.markdown-content`

## Управление состоянием

Использует хуки React для управления состоянием:
- `useState` для сообщений, ввода, загрузки и табличных данных
- `useRef` для DOM-ссылок и накопления потокового контента
- `useEffect` для побочных эффектов (загрузка данных, автопрокрутка, изменение размера текстового поля)

### Ключевые переменные состояния

- `messages` - массив объектов сообщений с id, content, role, timestamp
- `inputMessage` - текущее значение текстового поля
- `isLoading` - булево значение, указывающее на активный API-запрос
- `tableData` - массив табличных записей из APITable
- `streamingContentRef` - ref для накопления фрагментов потокового ответа

## Интеграция API

### OpenRouter API

Аутентификация через Bearer-токен в заголовке Authorization. Потоковые ответы с использованием типа контента `text/event-stream`. Поддерживает различные модели LLM через унифицированный интерфейс.

**Формат запроса:**
```
{
"model": "string",
"messages": [{"role": "string", "content": "string"}],
"stream": true,
"max_tokens": number,
"temperature": number
}
```

### APITable API

RESTful API с аутентификацией через Bearer-токен. Возвращает пагинированные JSON-ответы. Поддерживает фильтрацию, сортировку и выбор полей.

**Формат ответа:**
```
{
"code": 200,
"success": true,
"data": {
"total": number,
"records": [{"recordId": "string", "fields": {}}]
}
}
```

## Обработка ошибок

- Ошибки API перехватываются и записываются в консоль
- Пользовательские сообщения об ошибках отображаются в чате
- Неудачные запросы приводят к сообщению об ошибке от ассистента
- Сетевые ошибки обрабатываются корректно без сбоя виджета

## Соображения производительности

- Потоковые ответы обеспечивают мгновенную обратную связь
- Автопрокрутка использует плавное поведение для улучшения UX
- Расчет высоты текстового поля оптимизирован с помощью useEffect
- Рендеринг сообщений оптимизирован с использованием key props
- Пустые сообщения отфильтровываются из отображения
- Ref используется для накопления потока во избежание избыточного ре-рендеринга
